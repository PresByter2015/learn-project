# 事件循环与消息队列
回到事件循环 event loop
其实 事件循环 机制和 消息队列 的维护是由事件触发线程控制的。
事件触发线程 同样是浏览器渲染引擎提供的，它会维护一个 消息队列。
JS引擎线程遇到异步（DOM事件监听、网络请求、setTimeout计时器等...），会交给相应的线程单独去维护异步任务，等待某个时机（计时器结束、网络请求成功、用户点击DOM），然后由 事件触发线程 将异步对应的 回调函数 加入到消息队列中，消息队列中的回调函数等待被执行。
同时，JS引擎线程会维护一个 执行栈，同步代码会依次加入执行栈然后执行，结束会退出执行栈。

如果执行栈里的任务执行完成，即执行栈为空的时候（即JS引擎线程空闲），事件触发线程才会从消息队列取出一个任务（即异步的回调函数）放入执行栈中执行。

> 消息队列是类似队列的数据结构，遵循先入先出(FIFO)的规则。

执行完了后，执行栈再次为空，事件触发线程会重复上一步操作，再取出一个消息队列中的任务，这种机制就被称为事件循环（event loop）机制。

# 宏任务与微任务
所有任务分为 macrotask 和 microtask:


- macrotask：主代码块、setTimeout、setInterval,setImmediate等（可以看到，事件队列中的每一个事件都是一个 macrotask，现在称之为宏任务队列）
- microtask：Promise、process.nextTick等

`process`、`setImmediate`、`setTimeout`区别：
- setImmediate为一次Event Loop执行完毕后调用。
- setTimeout则是通过计算一个延迟时间后进行执行。
- nextTick，在下一个宏任务开始之前所执行
- async函数在await之前的代码都是同步执行的，可以理解为await之前的代码属于new Promise时传入的代码，await之后的所有代码都是在Promise.then中的回调
- Promise立即执行，then函数分发到微任务Event Queue，process.nextTick分发到微任务Event Queue


在某一个macrotask执行完后，在重新渲染与开始下一个宏任务之前，就会将在它执行期间产生的所有microtask都执行完毕（在渲染前）

> 在node环境下，process.nextTick的优先级高于Promise，也就是说：在宏任务结束后会先执行微任务队列中的nextTickQueue，然后才会执行微任务中的Promise。

执行机制：
1. 执行一个宏任务（栈中没有就从事件队列中获取）
2. 执行过程中如果遇到微任务，就将它添加到微任务的任务队列中
3. 宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行）
4. 当前宏任务执行完毕，开始检查渲染，然后GUI线程接管渲染
5. 渲染完毕后，JS引擎线程继续，开始下一个宏任务（从宏任务队列中获取）
 
JS引擎线程会维护一个执行栈，同步代码会依次加入到执行栈中依次执行并出栈。
JS引擎线程遇到异步函数，会将异步函数交给相应的Webapi，而继续执行后面的任务。
Webapi会在条件满足的时候，将异步对应的回调加入到消息队列中，等待执行。
执行栈为空时，JS引擎线程会去取消息队列中的回调函数（如果有的话），并加入到执行栈中执行。
完成后出栈，执行栈再次为空，重复上面的操作，这就是事件循环(event loop)机制。

**所有会进入的异步都是指的事件回调中的那部分代码**
也就是说new Promise在实例化的过程中所执行的代码都是同步进行的，而then中注册的回调才是异步执行的。
在同步代码执行完成后才回去检查是否有异步任务完成，并执行对应的回调，而微任务又会在宏任务之前执行。

